#!/usr/bin/perl

use strict;
use English;
use Cwd "abs_path";
use Template;
use Getopt::Long qw(:config posix_default no_ignore_case gnu_compat);
use JSON::XS;

$0 =~ m"^(.*)/";
our $TOOLHOME = abs_path( "$1/.." // '..' );
our $CONFDIR                 = "$TOOLHOME/conf";
our $BINDIR                  = "$TOOLHOME/bin";
our $TMPDIR                  = "$TOOLHOME/tmp";
our $STATUSDIR               = "$TOOLHOME/status";
our $LOGDIR                  = "$TOOLHOME/log";
our $WELLKNOWNSDIR           = "$TOOLHOME/conf/wellknowns";
our $DETECTDIR               = "$TOOLHOME/detect";

#### deprecated
our $SPOOLDIR                = "$TOOLHOME/spool";
our $ANOMALYLOGDIR           = "$TOOLHOME/anomalylog";
our $TRAFFICLOGDIR           = "$TOOLHOME/trafficlog";
our $UNMONITOREDLOGDIR       = "$TOOLHOME/unmonitoredlog";
our $CAPTUREDLOGDIR          = "$TOOLHOME/capturedlog";
our $MULTILINE2SINGLELINEDIR = "$TOOLHOME/multiline2singleline";
our $FLUENTDCONFDIR          = "$TOOLHOME/conf/fluentd";
our $TRAFFICSDIR             = "$TOOLHOME/conf/traffics";
our $GARAGEDIR               = "$TOOLHOME/garage";
our $CATALOGUEDIR             = "$TOOLHOME/catalogue";
####

our $CONCATFILTER_CONFFILE      = "$CONFDIR/concatfilter.conf";
our $ANOMALYMONITOR_CONFFILE    = "$CONFDIR/anomalymonitor.conf";
our $TRANSACTIONFILTER_CONFFILE = "$CONFDIR/transactionfilter.conf";
our $TRAFFICMONITOR_CONFFILE    = "$CONFDIR/trafficmonitor.conf";

####
sub get_logstatus ($$) {
	my ($dir, $regexp) = @_;
	my $status = {};
	opendir my $d, $dir or do {
		die "$dir: cannot open, stoped";
	};
	while( my $e = readdir $d ){
		next if $e =~ m"^\.";
		next unless $e =~ m"^$regexp$";
		next unless -f "$dir/$e";
		my ($dev, $inode, $mode, $nlink, $uid, $gid, $rdev, $size) =
			stat "$dir/$e";
		$status->{$e} = {"size" => $size};
	}
	close $d;
	return $status;
}

sub load_logstatus ($) {
	my ($statusname) = @_;
	my $f = "$STATUSDIR/logstatus.$statusname";
	open my $h, '<', $f or return {};
	my $status = {};
	while( <$h> ){
		chomp;
		my ($file, $size) = split m"\t";
		$status->{$file} = {size => $size};
	}
	close $h;
	return $status;
}

sub store_logstatus ($$) {
	my ($statusname, $status) = @_;
	my $f = "$STATUSDIR/logstatus.$statusname";
	my $g = "$STATUSDIR/.logstatus.$statusname";
	open my $h, '>', $g or do {
		die "$g: cannot open, stoped";
	};
	foreach my $file ( sort {$a cmp $b} keys %$status ){
		my $values = $status->{$file};
		print $h join("\t", $file, $values->{size}), "\n";
	}
	close $h;

	unlink $f if -f $f;
	rename $g, $f or do {
		die "$f: cannot open, stoped";
	}
}

sub read_partial ($$$) {
	my ($file, $offset, $length)= @_;
	my $buff;
	open my $h, '<', $file or do {
		die "$file: cannot open, stopped";
	};
	seek $h, $offset, 0;
	read $h, $buff, $length;
	close $h;
	return $buff;
}

sub read_incremental ($$$&) {
	my ($dir, $statusname, $regexp, $handler) = @_;
	my $laststatus = load_logstatus $statusname;
	my $currstatus = get_logstatus $dir, $regexp;
	
	while( my ($file, $currvalues) = each %$currstatus ){
		my $lastvalues = $laststatus->{$file} || {'size' => 0};
		my $currsize = $currvalues->{"size"};
		my $lastsize = $lastvalues->{"size"};
		next if $currsize == $lastsize;
		$lastsize = 0 if $currsize < $lastsize;
		my $offset = $lastsize;
		my $length = $currsize - $lastsize;
		my $partial = read_partial "$dir/$file", $offset, $length;
		&$handler( $file, $partial );
	}

	store_logstatus $statusname, $currstatus;
}

sub time2string ($) {
	my ($time) = @_;
	my ($sec, $min, $hour, $day, $mon, $year) = localtime $time;
	return sprintf("%04d-%02d-%02d_%02d:%02d:%02d",
		$year+1900, $mon+1, $day, $hour, $min, $sec); 
}

sub read_statisticsfile ($) {
	my ($file) = @_;
	my $stats = {};
	if( open my $h, '<', $file ){
		my $json = join '', <$h>;
		close $h;
		my $decoder = JSON::XS->new;
		$stats = $decoder->decode( $json );
        }
	return $stats;
}

####
sub glob2fixed ($) {
	my @fields;
	foreach my $field ( split m"\.", $_[0] ){
		next if $field eq '**';
		next if $field eq '*';
		$field =~ s/\*//g;
		push @fields, $field;
	}
	return join ".", @fields;
}

sub glob2regexp ($) {
	my @fields;
	foreach my $field ( split m"\.", $_[0] ){
		if    ( $field eq '**' ){ push @fields, ".*";
		}elsif( $field eq '*' ) { push @fields, "[^.]*";
		}else { $field =~ s/\*/[^.]*/g; push @fields, $field; }
	}
	my $regexp = join "\\.", @fields;
	return qr"^$regexp$";
}

sub tagglob2singlelinelogregexp ($) {
	my ($tagglob) = @_;
	return glob2regexp $tagglob;
}

sub tagglob2anomalylogregexp ($) {
	my ($tagglob) = @_;
	my $tag = quotemeta glob2fixed $tagglob;
	return qr"^$tag\.\d{4}-\d{2}-\d{2}(\.\d+)?$";
}

sub read_monitor_conf () {
	my $f = "$CONFDIR/monitor.conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	my @trashbox;
	my @multiline2singleline;
	my @anomalymonitor;
	my @trafficmonitor;
	my @errors;
	my $context;
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
	
		if    (	m"^\s*define_trashbox\s*" ){
			$context = {
				type => 'trashbox',
				name => undef,
			};
			next;
		}elsif( m"^\s*define_multiline2singleline\s*$" ){
			$context = {
				type => 'multiline2singleline',
				name => undef,
			};
			next;
		}elsif( m"^\s*define_anomalymonitor\s+([-\w]+)\s*$" ){
			$context = {
				type => 'anomalymonitor',
				name => $1,
			};
			next;
		}elsif( m"^\s*define_trafficmonitor\s+([-\w]+)\s*$" ){
			$context = {
				type => 'trafficmonitor',
				name => $1,
			};
			next;
		}elsif( m"^\s*parses_head_of_block_as\s+(\S.*)$" ){
			$$context{firstline} = $1;
			next;
		}elsif( m"^\s*calls\s+(\S.*)$" ){
			$$context{command} = $1;
			next;
		}elsif( m"^\s*captures\s+(\S.*)$" ){
			# continue to following block
		}else{
			print STDERR "$f:$.: illegal format.\n";
			next;
		}

		# when "captures ..."
		next unless $context;
		my $type = $$context{type};
		my $name = $$context{name};
		my $tagglob = $1;
		my $directive = {
			type        => $type,
			name        => $name,
			context     => $context,
			tagglob     => $tagglob,
			tagfixed    => glob2fixed $tagglob,
			outputlogregexp
				=> tagglob2anomalylogregexp $tagglob,
			inputlogregexp
				=> tagglob2singlelinelogregexp $tagglob,
		};
		if    ( $type eq 'trashbox' ){
			push @trashbox, $directive;
		}elsif( $type eq 'multiline2singleline' ){
			push @multiline2singleline, $directive;
		}elsif( $type eq 'anomalymonitor' ){
			push @anomalymonitor, $directive;
			my $f = "$WELLKNOWNSDIR/$name.regexp";
			push @errors, "$f: not found." unless -f $f;
			$$directive{regexp} = $name;
			$$directive{regexpfile} = $f;
		}elsif( $type eq 'trafficmonitor' ){
			push @trafficmonitor, $directive;
			my $f = "$TRAFFICSDIR/$name.conf";
			my $l = "$TRAFFICLOGDIR/$name-%y-%m-%d.ltsv";
			my $d = "$TRAFFICLOGDIR/$name";
			push @errors, "$f: not found." unless -f $f;
			push @errors, "$d: cannot create." unless -d $d or mkdir $d;
			$$directive{traffic} = $name;
			$$directive{conffile} = $f;
			$$directive{logfile} = $l;
			$$directive{trafficlogdir} = $d;
		}else{
			die;
		}
	}
	close $h;

	return {
		trashbox	     => [@trashbox],
		multiline2singleline => [@multiline2singleline],
		anomalymonitor	     => [@anomalymonitor],
		trafficmonitor	     => [@trafficmonitor],
		errors		     => [@errors],
	};
}
 
sub get_garage_index () {
	my @r;
	opendir my $d, $GARAGEDIR or do {
		die "$GARAGEDIR: cannot open. stopped";
	};
	while( my $e = readdir $d ){
		next if $e =~ m"^\.";
		next unless $e =~ m"^([-.\w]+)\.stats$";
		push @r, $1;
	}
	close $d;
	return @r;
}

sub get_catalogue_index () {
	my @r;
	opendir my $d, $CATALOGUEDIR or do {
		die "$CATALOGUEDIR: cannot open. stopped";
	};
	while( my $e = readdir $d ){
		next if $e =~ m"^\.";
		next unless $e =~ m"^([-.\w]+)\.samples$";
		push @r, $1;
	}
	close $d;
	return @r;
}

#### test confs

sub read_regexpfile ($) {
	my ( $f ) = @_;
	open my $h, '<', $f or do {
		print "read_regexpfile: $f: cannot read.\n";
		return undef, undef;
	};
	my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,
	    $atime, $mtime, $ctime, $blksize, $blocks) = stat $h;
	my $regexp = join '', <$h>;
	chomp $regexp;
	close $h;
	my $regexp_compiled;
	eval {
		$regexp_compiled = qr"^$regexp$";
	};
	unless( defined $regexp_compiled ){
		print "read_regexpfile: $f: cannot compile.\n";
		return undef, undef;
	}
	return $regexp_compiled, $mtime;
}

sub test_concatfilter_conf () {
	my @conf;
	my $rule;
	open my $h, '<', $CONCATFILTER_CONFFILE or do {
		die "cannot open $CONCATFILTER_CONFFILE: $OS_ERROR, stopped";
	};
	while (<$h>) {
		next if m"^\s*(#|$)";
		if    ( m"^\s*concat_rule\s*$" ){
			$rule = {
				'name' => "$CONCATFILTER_CONFFILE:$.",
				'type' => 'pattern-first',
				'limit_line' => 100,
				'limit_time' => 10*60,
			};
			push @conf, $rule;
		}elsif( m"^\s*target\s+(\S.*)$" ){
			push @{$$rule{targets}}, qr"^($1)$";
		}elsif( m"^\s*pattern\s+(\S.*)$" ){
			push @{$$rule{patterns}}, qr"^($1)$";
		}elsif( m"^\s*type\s+(\S.*)$" ){
			$$rule{type} = $1;
		}else{
			print STDERR
				"$CONCATFILTER_CONFFILE:$.: illegal format, ignored.\n";
		}
	}
	close $h or do {
		die "close failed for $CONCATFILTER_CONFFILE: $OS_ERROR, stopped";
	};
	return \@conf;
}

sub test_anomalymonitor_conf () {
	my @conf;
	my $rule;
	my $redirect;
	open my $h, '<', $ANOMALYMONITOR_CONFFILE or do {
		die "cannot open $ANOMALYMONITOR_CONFFILE: $OS_ERROR, stopped";
	};
	while (<$h>) {
		next if m"^\s*(#|$)";
		if    ( m"^\s*anomalymonitor_rule\s*$" ){
			$rule = { 'name' => "$ANOMALYMONITOR_CONFFILE:$." };
			push @conf, $rule;
		}elsif( m"^\s*target\s+(\S.*)$" ){
			my $re;
			eval { $re = qr"^($1)$"; };
			if( $@ ){ die "$ANOMALYMONITOR_CONFFILE:$.: $@, stopped"; }
			push @{$$rule{targets}}, $re;
		}elsif( m"^\s*pattern\s+(\S.*)$" ){
			$$rule{pattern} = $1;
			my $f = "$WELLKNOWNSDIR/$1.regexp";
			$$rule{pattern_file} = $f;
			my ($regexp, $mtime) = read_regexpfile $f;
			unless( defined $regexp ){
				print STDERR "$ANOMALYMONITOR_CONFFILE:$.:" .
					"$f: cannot open.\n";
				$$rule{pattern_mtime} = undef;
				$$rule{pattern_regexp} = undef;
				next;
			}
			$$rule{pattern_mtime} = $mtime;
			$$rule{pattern_regexp} = $regexp;
			print "anomalymonitor_conf: $f: loaded.\n";
		}elsif( m"^\s*redirect\s+(\S.*)$" ){
			$redirect = {
				'name' => "$ANOMALYMONITOR_CONFFILE:$.",
				'event' => $1,
			};
			push @{$$rule{redirects}}, $redirect;
		}elsif( m"^\s*tag\s+(\S.*)$" ){
			$$redirect{tag} = $1;
		}elsif( m"^\s*message\s+(\S.*)$" ){
			$$redirect{message} = $1;
		}else{
			print STDERR "$ANOMALYMONITOR_CONFFILE:$.:" .
				" illegal format, ignored.\n";
		}
	}
	close $h or do {
		die "close failed for $ANOMALYMONITOR_CONFFILE: $OS_ERROR, stopped";
	};
	return \@conf;
}

sub test_report_conf () {
	my $f = "$CONFDIR/report.conf";
	open my $h, '<', $f or do {
		die "$f: cannot open, stopped";
	};
	my @alerts;
	my @flash_reports;
	my @daily_reports;
	my %param;

	my $section;
	my $subsection;
	my @errors;
	while( <$h> ){
		chomp;
		next if m"^\s*(#|$)";
		if( m"^(\w+)=(\S.*)$" ){
			$param{$1} = $2;
		}elsif( m"^\s*define_alert\s+(\w+)\s*$" ){
			$section = {
				name        => $1,
				maxsize     => 1000,
				min_interval => 30,
			};
			push @alerts, $section;

		}elsif( m"^\s*captures_anomalylogs\s*$" ){
			$subsection = {
			};
			push @{$$section{from_anomalylogs}}, $subsection;

		}elsif( m"^\s*captures_unmonitoredlogs\s*$" ){
			$subsection = {
			};
			push @{$$section{from_unmonitoredlogs}}, $subsection;

		}elsif( m"^\s*captures_trafficlogs\s*$" ){
			$subsection = {
			};
			push @{$$section{from_trafficlogs}}, $subsection;

		}elsif( m"^\s*(?:marked_as|matching_mark)\s+(\S.*)$" ){
			push @{$$subsection{marks}}, $1;
			
		}elsif( m"^\s*(?:not_marked_as|unmatching_mark)\s+(\S.*)$" ){
			push @{$$subsection{nomarks}}, $1;

		}elsif( m"^\s*(?:tagged_as|matching_tag)\s+(\S.*)$" ){
			push @{$$subsection{tag_regexps}}, qr"^$1$";

		}elsif( m"^\s*(?:named_as|matching_name|matching_trafficname)\s+(\S.*)$" ){
			push @{$$subsection{trafficname_regexps}}, qr"^$1$";

		}elsif( m"^\s*matching_event\s+(\S.*)$" ){
			push @{$$subsection{event_regexps}}, qr"^$1$";

		}elsif( m"^\s*matching_monitorname\s+(\S.*)$" ){
			push @{$$subsection{monitorname_regexps}}, qr"^$1$";

		}elsif( m"^\s*(?:passing_through|matching_route)\s+(\S.*)$" ){
			push @{$$subsection{route_regexps}}, qr"^$1$";

		}elsif( m"^\s*marks_logs_as\s+(\S.*)$" ){
			push @{$$section{mark_logs_as}}, $1;

		}elsif( m"^\s*define_flash_report\s+(\w+)\s*$" ){
			$section = {
				name           => $1,
				maxsize        => 1000,
				min_interval   => 30,
				sent_to        => [],
				contains_alert => [],
			};
			push @flash_reports, $section;

		}elsif( m"^\s*define_daily_report\s+(\w+)\s*$" ){
			$section = {
				name           => $1,
				max_size       => 1000,
				min_interval   => 30,
				sent_to        => [],
				contains_alert => [],
			};
			push @daily_reports, $section;

		}elsif( m"^\s*contains_alert\s+(\S.*)$" ){
			push @{$$section{contains_alert}}, qr"^$1$";

		}elsif( m"^\s*sent_to\s+(\S+)$" ){
			push @{$$section{sent_to}}, $1;

		}elsif( m"^\s*max_size\s+(\d+)$" ){
			$$section{max_size} = 0+$1;

		}elsif( m"^\s*min_interval\s+(\d+)$" ){
			$$section{min_interval} = 0+$1;

		}else{
			push @errors, "$f:$.: illegal format.\n";
			next;
		}
	}
	close $h;

	if( @errors ){
		foreach my $error ( @errors ){
			print STDERR $error, "\n";
		}
		die;
	}
	return {
		alerts         => [@alerts],
		flash_reports  => [@flash_reports],
		daily_reports  => [@daily_reports],
		errors	       => [@errors],
		param          => {%param},
	};
}
 
sub test_wellknown_rules_conf ($) {
	my ($conffile) = @_;
	my $mark = "rule0000";
	my %mark2replace;
	my @res;
	open my $h, '<', $conffile or die "$conffile: cannot open, stopped";

	while( <$h> ){
		chomp;
		s{^\s*}{}g;
		next if m{^\s*($|#)};
		my @c = split m{\s+};
		if( m"^\s*(ignore|replace)\s+(\S.*)$" ){
			my $pattern = $2;
			eval { qr"$pattern"; };
			unless( $@ eq "" ){
				print STDERR "$conffile:$.: syntax error. \n";
				print STDERR "$conffile:$.: $@\n";
				next;
			}
			push @res, "$pattern(*:$mark)";
			$mark2replace{$mark} = $pattern;
			$mark++;
		}elsif( m"^\s*(as|with)\s+(\S.*)$" ){
			my $pattern = $2;
			eval { qr"$pattern"; };
			unless( $@ eq "" ){
				print STDERR "$conffile:$.: syntax error. \n";
				print STDERR "$conffile:$.: $@\n";
				next;
			}
			my $lastmark = $mark;
			$lastmark--;
			$mark2replace{$lastmark} = $pattern;
		}else{
			print STDERR "$conffile:$.: syntax error.\n";
			next;
		}
	}
	close $h;
	my $re = "(" . join("|", @res) . ")";

	eval { qr"$re"; };
	if( $@ ){
		print STDERR "$conffile:$.: $re\n";
		die "$conffile:$.: cannot compile, stopped";
		next;
	}
	return qr"$re", %mark2replace;
}

sub test_wellknown_regexp_conf ($) {
	my ($regexpfile) = @_;
        open my $h, '<', $regexpfile or die "$regexpfile: cannot open, stopped";
	my $pattern = join '', <$h>;
	close $h;
	chomp $pattern;
	return qr"^$pattern$";
}

sub test_traffic_conf ($) {
	my ($conffile) = @_;
	my @transaction_defs;
	my @traffic_defs;
	my %transaction2traffics;

	my $context;
	my $block;
	my $subblock;

	open my $h, '<', $conffile or die "$conffile: cannot open, stopped";
	while( <$h> ){
		chomp;
		s{^\s*}{}g;
		next if m{^($|#)};
		if    ( m"^\s*define_simple_transaction\s+(\w+)\s*$" ){
			$context = 'simple_transaction';
			$block = { type => 'simple', name => $1 };
			push @transaction_defs, $block;
			
		}elsif( m"^\s*define_multiline_transaction\s+(\w+)\s*$" ){
			$context = 'multiline_transaction';
			$block = { type => 'multiline', name => $1 };
			push @transaction_defs, $block;
			
		}elsif( m"^\s*captures_logs_tagged_as\s+(\S.*)$" ){
			push @{$$block{tag_regexps}}, qr"$1";

		}elsif( m"^\s*captures_logs_saying\s+(\S.*)$" ){
			push @{$$block{message_regexps}}, qr"$1";

		}elsif( m"^\s*begin_message\s+(\S.*)$" ){
			push @{$$block{begin_message_regexps}}, qr"$1";

		}elsif( m"^\s*end_message\s+(\S.*)$" ){
			push @{$$block{end_message_regexps}}, qr"$1";

		}elsif( m"^\s*identified_by\s+(\w+(,\w+)*)\s*$" ){
			$$block{identified_by} = [split m",", $1];

		}elsif( m"^\s*define_traffic\s+([/\w]+)\s*$" ){
			$context = 'traffic';
			$block = {
				name => $1,
				trigger_defs => [],
				treats       => [],
			};
			push @traffic_defs, $block;

		}elsif( m"^\s*treats\s+(\w+)\s*$" ){
			push @{$$block{treats}}, $1;
			push @{$transaction2traffics{$1}}, $block;

		}elsif( m"^\s*counted_by_each\s+(\w+(,\w+)*)\s*$" ){
			$$block{counted_by_each} = [split m",", $1];

		}elsif( m"^\s*during_last\s+(\d+)(m|h|d)?\s*$" ){
			my $during_last = $1 * 60;
			$during_last *= 60      if $2 eq 'h';
			$during_last *= 24 * 60 if $2 eq 'd';
			$$block{during_last} = $during_last;

		}elsif( m"^\s*define_trigger(\s+([\w]+))?\s*$" ){
			$context = 'trigger';
			$subblock = { name => $2 };
			push @{$$block{trigger_defs}}, $subblock;

		}elsif( m"^\s*causes\s+(\S.*)\s*$" ){
			$$subblock{causes} = $1;

		}elsif( m"^\s*pulled_if_total_exceeds\s+(\d+)\s*$" ){
			$$subblock{if_exceeds} = $1;

		}elsif( m"^\s*pulled_unless_total_exceeds\s+(\d+)\s*$" ){
			$$subblock{unless_exceeeds} = $1;

		}elsif( m"^\s*pulled_if_not_exists\s+(\S.*)$" ){
			$$subblock{if_not_exists} = $1;

		}elsif( m"^\s*targets\s+(\S.*)$" ){
			push @{$$subblock{rules}}, ['target', qr"$1"];

		}elsif( m"^\s*ignores\s+(\S.*)$" ){
			push @{$$subblock{rules}}, ['ignore', qr"$1"];

		}else{
			die "$conffile:$.: illegal format, stopped";
		}
	}
	close $h;

	return {
		transaction_defs => \@transaction_defs,
		traffic_defs     => \@traffic_defs,
		transaction2traffics => \%transaction2traffics,
	};
}

#### sub-commands

sub subcmd_test_confs () {
	my $monitor_conf = test_anomalymonitor_conf;
	my $concatfilter_conf  = test_concatfilter_conf;
	my $report_conf = test_report_conf;
	# TODO: tepmlates
	# TODO: regexps

	opendir my $h, $WELLKNOWNSDIR or do {
		die "$WELLKNOWNSDIR: illegal format, stopped";
	};
	while( my $e = readdir $h ){
		if( $e =~ m"^\w+\.rules$" ){
			my $rules_conf = test_wellknown_rules_conf "$WELLKNOWNSDIR/$e";
		}elsif( $e =~ m"^\w+\.regexp$" ){
			my $regexp_conf = test_wellknown_regexp_conf "$WELLKNOWNSDIR/$e";
		}
	}
	close $h;

	opendir my $h, $TRAFFICSDIR or do {
		die "$TRAFFICSDIR: illegal format, stopped";
	};
	while( my $e = readdir $h ){
		next unless $e =~ m"^\w+\.conf$";
		my $traffic_conf = test_traffic_conf "$TRAFFICSDIR/$e";
	};
	close $h;
	exit 0;
}

sub _unmonitoredlog2monitor ($$) {
	my ($conf, $f) = @_;
	return undef, undef unless $f =~ m"^foucault03log\.(.*)_\d{4}-\d{2}-\d{2}\.log$";
	my $basename = $1;

	foreach my $m ( @{ $$conf{anomalymonitor} } ){
		my $monitorname = $$m{name};
		my $regexp      = $$m{inputlogregexp};
		my $fixed       = $$m{tagfixed};
		my $pattern     = $$m{pattern};
		next unless $basename =~ $regexp;
		next unless defined $monitorname;
		return $basename, $monitorname;
	}

	return $basename, undef;
}
	
sub subcmd_list_unmonitoredlog ($) {
	my ($conf) = @_;
	
	opendir my $d, $UNMONITOREDLOGDIR or do {
		die "$UNMONITOREDLOGDIR: cannot open. stopped";
	};
	my %unmonitoredlogs;
	my @unmonitoredlogs;
	while( my $e = readdir $d ){
		next if $e =~ m"^\.";
		my ($basename, $monitorname) = _unmonitoredlog2monitor $conf, $e;
		next if $unmonitoredlogs{$basename};
		$unmonitoredlogs{$basename} = 1;
		push @unmonitoredlogs, [$basename, $monitorname];
	}
	close $d;

	foreach my $unmonitoredlog ( sort {$$a[0] cmp $$b[0]} @unmonitoredlogs ){
		my $basename    = $$unmonitoredlog[0];
		my $monitorname = $$unmonitoredlog[1];

		print "$basename\n";
		if( $monitorname ){
			my $samples = "$WELLKNOWNSDIR/$monitorname.samples";
			if( -f $samples ){
				print "	(will monitored by $monitorname, has samples)\n";
			}else{
				print "	(will monitored by $monitorname, no sample)\n";
			}
		}
	}
	exit 0;
}

sub _import_unmonitoredlog ($$) {
	my ($monitor, $samples) = @_;
	my $samplesfile = "$WELLKNOWNSDIR/$monitor.samples";
	my $regexpfile  = "$WELLKNOWNSDIR/$monitor.regexp";
	my $rulesfile   = "$WELLKNOWNSDIR/$monitor.rules";

	my $cmd;
	$cmd .= "cp $CONFDIR/rules.template $rulesfile ; " unless -f $rulesfile;
	$cmd .= "$BINDIR/panopticfilter strip -r $rulesfile";
	$cmd .= " -p $regexpfile" if -f $regexpfile;
	$cmd .= " >> $samplesfile";
	open my $h, "|-", $cmd or do {
		die;
	};
	print $h $samples;
	close $h;
	unlink $samplesfile unless -s $samplesfile;
}

sub subcmd_import_unmonitoredlog ($) {
	my ($conf) = @_;

	read_incremental
		$UNMONITOREDLOGDIR,
		"import_unmonitoredlog",
		qr"^unmonitoredlog\..*$",
		sub {
			my ($unmonitoredlog, $samples) = @_;
			my ($basename, $monitor) = _unmonitoredlog2monitor
				$conf, $unmonitoredlog;
			return undef unless defined $monitor;
			return _import_unmonitoredlog $monitor, $samples;
		};
	exit 0;
}

sub subcmd_strip_wellknown_samples () {
	opendir my $d, $WELLKNOWNSDIR or do {
		die "$WELLKNOWNSDIR: cannot open. stopped";
	};
	my @samples;
	while( my $e = readdir $d ){
		next if $e =~ m"^\.";
		next unless -s "$WELLKNOWNSDIR/$e";
		next unless $e =~ m"^([-\w]+)(\+[-\w]+)?\.samples$";
		next unless -f "$WELLKNOWNSDIR/$1.rules";
		push @samples, {rules => $1, name => "$1$2"};
	}
	close $d;
	foreach my $sample ( sort @samples ){
		my $name = $sample->{name};
		my $rules = $sample->{rules};
		my $cmd;
		$cmd .= "$BINDIR/panopticfilter strip -r $WELLKNOWNSDIR/$rules.rules";
		$cmd .= " < $WELLKNOWNSDIR/$name.samples";
		$cmd .= " > $WELLKNOWNSDIR/$name.samples.new ; ";
		$cmd .= "mv $WELLKNOWNSDIR/$name.samples.new";
		$cmd .= " $WELLKNOWNSDIR/$name.samples";
		system $cmd;
	}
	exit 0;
}

sub _parse_detectedanomaly ($) {
	my ($samples) = @_;
	my $decoder = JSON::XS->new;
	my %r;
	foreach my $sample ( split m"\n", $samples ){
		next if $sample =~ m"^\s*$";
		utf8::decode($sample);
		eval {
			my $s = $decoder->decode( $sample );
			my $pattern  = $$s{pattern};
			my $message  = $$s{message};
			my $unixtime = $$s{unixtime};
			utf8::encode($message);
		
			push @{$r{$pattern}}, [$unixtime, $message];
		};
		if( $@ ){
			print "error occured.\n";
			print "\tjson:\t$sample\n";
			print "\texception:\t$@\n";
		}
	}
	return %r;
}

sub _write_detectedanomaly (%) {
	my (%samples) = @_;
	my $encoder = JSON::XS->new;

	while( my ($pattern, $anomalies) = each %samples ){
		my $statsfile   = "$GARAGEDIR/$pattern.stats";
		my $rulefile    = "$WELLKNOWNSDIR/$pattern.rules";
		my $patternfile = "$WELLKNOWNSDIR/$pattern.regexp";

		print "DEBUG: $pattern: ", int(@$anomalies), "\n";

		my $cmd;
		unless( -f $statsfile ){
			$cmd .= "cp /dev/null $statsfile ;";
			print "$statsfile: created.\n";
		}
		unless( -f $rulefile ){
			$cmd .= "cp $CONFDIR/rules.template $rulefile ;";
			print "$rulefile: created.\n";
		}

		$cmd .= "$BINDIR/panopticfilter analyze";
		$cmd .= " -r $rulefile";
		$cmd .= " -s $statsfile";
		$cmd .= " -p $patternfile" if -f $patternfile;
		open my $h, "|-", $cmd or do {
			die "command \"$cmd\", stopped";
		};
		foreach my $anomaly ( @$anomalies ){
			my ($unixtime, $message) = @$anomaly;
			utf8::decode($message);
			my $json = $encoder->encode( {
				unixtime => $unixtime,
				message => $message,
			} );
			utf8::encode($json);
			print $h "$json\n";
		}
		close $h;
	}
}

sub subcmd_drop_into_garage () {
	read_incremental
		$DETECTDIR,
		"drop_detectedanomaly_into_garage",
		qr"^anomaly\.(\d{4}-\d{2}-\d{2})$",
		sub {
			my ($detectedanomalyfile, $samples) = @_;
			print "reading $detectedanomalyfile ...\n";
			my %samples = _parse_detectedanomaly $samples;
			_write_detectedanomaly %samples;
		};
	exit 0;
}

sub _tidy_up_garage ($) {
	my ($pattern) = @_;
	unless( -s "$GARAGEDIR/$pattern.stats" ){
		unlink "$GARAGEDIR/$pattern.stats";
		return;
	}

	my $cmd;
	$cmd .= "$BINDIR/panopticfilter reanalyze";
	$cmd .= " -r $WELLKNOWNSDIR/$pattern.rules";
	$cmd .= " -s $GARAGEDIR/$pattern.stats";
	system $cmd;
}

sub subcmd_tidy_up_garage () {
	my @stats = get_garage_index;
	foreach my $i ( @stats ){
		_tidy_up_garage $i;
	}
	exit 0;
}

sub subcmd_clean_up_catalogue () {
	my @samples = get_catalogue_index;
	foreach my $i ( @samples ){
		unlink "$CATALOGUEDIR/$i.samples";
	}
	exit 0;
}

sub subcmd_export_catalogue ($\@\@) {
	my ($include_wellknowns, $patterns, $conds) = @_;
	my @stats = get_garage_index;
	OUTSIDE:
	foreach my $i ( @stats ){
		foreach my $pattern ( @$patterns ){
			my ($c, $regexp) = @$pattern;
			if    ( $c eq 'match' ){
				next OUTSIDE unless $i =~ m"^$regexp$";
			}elsif( $c eq 'unmatch' ){
				next OUTSIDE if $i =~ m"^$regexp$";
			}
		}
		my $statsfile     = "$GARAGEDIR/$i.stats";
		my $regexpfile    = "$WELLKNOWNSDIR/$i.regexp";
		my $cataloguefile = "$CATALOGUEDIR/$i.samples";
		my @conds = @$conds;
		my $cmd;
		$cmd .= "$BINDIR/panopticfilter export";
		$cmd .= " -p $regexpfile" unless $include_wellknowns;
		$cmd .= " -s $statsfile";
		$cmd .= " @conds";
		$cmd .= " > $cataloguefile";
		system $cmd;
		unlink $cataloguefile unless -s $cataloguefile;
	}
	exit 0;
}

sub subcmd_import_catalogue () {
	my %c;
	while( <STDIN> ){
		chomp;
		next unless m"^([-\w]+)\t(.*)$";
		my $pattern = $1;
		my $sample = $2;
		$c{$pattern} .= "$sample\n";
	}

	while( my ($pattern, $samples) = each %c ){
		open my $h, ">>", "$WELLKNOWNSDIR/$pattern.samples" or die;
		print $h $samples;
		close $h;
	}
	exit 0;
}

sub subcmd_filter_catalogue (@) {
	my ($limit) = @_;
	my $pass = undef;
	while( <STDIN> ){
		chomp;
		if( m"^# (.*)$" ){
			$pass = undef;
			foreach my $param ( split m"\s+", $1 ){
				die unless $param =~ m"^(\w+)=(.*)$";
				$pass = 1 if $1 eq "count" and $2 > $limit;
			}
			print "$_\n" if $pass;
		}elsif($pass){
			print "$_\n";
		}
	}
	exit 0;
}

####
sub get_mtime ($) {
	my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	    $atime,$mtime,$ctime,$blksize,$blocks) = stat $_[0];
	return $mtime;
}

sub subcmd_build_patterns () {
	opendir my $d, $WELLKNOWNSDIR or do {
		die "$WELLKNOWNSDIR: cannot open, stopped";
	};
	my %mtime;
	my %option;
	while( my $e = readdir $d ){
		next if $e =~ m"^\.";
		if    ( $e =~ m"^([-\w]+)\.regexp$" ){
			my $mtime = get_mtime "$WELLKNOWNSDIR/$e";
			next unless $mtime > 0;
			$mtime{$1}->{pattern} = $mtime;
		}elsif( $e =~ m"^([-\w]+)\.rules$" ){
			my $mtime = get_mtime "$WELLKNOWNSDIR/$e";
			next unless $mtime > 0;
			$mtime{$1}->{src} = $mtime if
				not defined($mtime{$1}->{src}) or
				$mtime > $mtime{$1}->{src};
		}elsif( $e =~ m"^([-\w]+)(?:\+([-\w]+))?\.samples$" ){
			my $mtime = get_mtime "$WELLKNOWNSDIR/$e";
			next unless $mtime > 0;
			$mtime{$1}->{src} = $mtime if
				not defined($mtime{$1}->{src}) or
				$mtime > $mtime{$1}->{src};
			push @{ $option{$1} }, $2 if $2;
		}
	}
	close $d;

	while( my ($k, $v) = each %mtime ){
		my $samplefile	  = "$WELLKNOWNSDIR/$k.samples";
		my $rulefile	  = "$WELLKNOWNSDIR/$k.rules";
		my $regexpfile	  = "$WELLKNOWNSDIR/$k.regexp";
		my $diagnosisfile = "$WELLKNOWNSDIR/$k.diagnosis";
		
		my $cmd;
		unless( -f $samplefile ){
                        $cmd .= "cp /dev/null $samplefile ;";
                        print "$samplefile: created.\n";
                }
		unless( -f $rulefile ){
                        $cmd .= "cp $CONFDIR/rules.template $rulefile ;";
                        print "$rulefile: created.\n";
                }
		next if -f $regexpfile and $$v{src} < $$v{pattern};
		$cmd .= "$BINDIR/panopticfilter build";
		$cmd .= " -r $rulefile -d $diagnosisfile";
		$cmd .= " -o $regexpfile -f $samplefile";
		foreach my $i ( @{$option{$k} // []} ){
			$cmd .= " -e $i -f $WELLKNOWNSDIR/$k+$i.samples";
		}
		system "$cmd\n";
	}

	exit 0;
}


####
my $cmd = shift @ARGV;
if    ($cmd eq 'test_confs'){
	subcmd_test_confs;

}elsif($cmd eq 'build_patterns'){
	subcmd_build_patterns;

}elsif($cmd eq 'strip_wellknown_samples'){
	subcmd_strip_wellknown_samples;

}else{
	print	"usage: % $0 <SUBCOMMAND>\n",
		"\n",
		"    SUBCOMMAND\n",
		"         test_confs\n",
		"         build_patterns\n",
		"         strip_wellknown_sample\n",
		"\n";
	exit 1;
}


####

exit 0;

 

